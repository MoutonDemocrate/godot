<?xml version="1.0" encoding="UTF-8"?>
<protocol name="wlr_layer_shell_unstable_v1">
  <copyright>
    Copyright Â© 2017 Drew DeVault

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the "Software"),
    to deal in the Software without restriction, including without limitation
    the rights to use, copy, modify, merge, publish, distribute, sublicense,
    and/or sell copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
    THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.
  </copyright>

  <interface name="zwlr_layer_shell_v1" version="4">
    <description summary="create surfaces that are layers of the desktop">
      Clients can use this interface to assign the surface_layer role to
      wl_surfaces. Such surfaces are assigned to a "layer" of the output and
      rendered with a defined z-depth respective to each other. They may also be
      anchored to the edges and corners of a screen and specify input handling
      semantics. This interface should be suitable for the implementation of
      many desktop shell components, and a broad number of other applications
      that interact with the desktop.
    </description>

    <request name="get_layer_surface">
      <description summary="create a layer_surface from a surface">
        Create a layer surface for an existing surface. This gives the surface
        the layer_surface role. Attempting to create a layer surface for a
        surface with another role, or setting the layer_surface role for a
        surface with an existing role, raises a protocol error.

        When the layer surface is destroyed, the surface is unmapped and the
        zwlr_layer_surface_v1 object becomes inert.

        The client must commit the surface in order for it to be mapped, or make
        it as a sub-surface and make its parent surface committed.
      </description>
      <arg name="id" type="new_id" interface="zwlr_layer_surface_v1"/>
      <arg name="surface" type="object" interface="wl_surface"/>
      <arg name="output" type="object" interface="wl_output" allow-null="true"/>
      <arg name="layer" type="uint" enum="layer" summary="layer to add this surface to"/>
      <arg name="name_space" type="string" summary="namespace for the layer surface"/>
    </request>

    <enum name="layer">
      <description summary="available layers for surfaces">
        These values indicate which layers a surface can be rendered in. They
        are ordered by z depth, bottom-most first. Traditional shell surfaces
        will typically be rendered between the bottom and top layers.
        Fullscreen shell surfaces are typically rendered at the top layer.
        Multiple surfaces can share a single layer, and ordering within a
        single layer is undefined.
      </description>
      <entry name="background" value="0"/>
      <entry name="bottom" value="1"/>
      <entry name="top" value="2"/>
      <entry name="overlay" value="3"/>
    </enum>

    <enum name="error">
      <entry name="role" value="0" summary="wl_surface has another role"/>
      <entry name="invalid_layer" value="1" summary="layer value is invalid"/>
      <entry name="already_constructed" value="2" summary="wl_surface has a buffer attached or committed"/>
    </enum>
  </interface>

  <interface name="zwlr_layer_surface_v1" version="4">
    <description summary="layer metadata interface">
      An interface that may be implemented by a wl_surface, for surfaces that
      are designed to be rendered as a layer of a stacked desktop-like
      environment.

      Layer surface state (layer, size, anchor, exclusive zone,
      margin, interactivity) is double-buffered, and will be applied at the
      time wl_surface.commit of the corresponding wl_surface is called.

      Attaching a null buffer to a layer surface unmaps it.

      Unmapping a layer_surface means that the surface cannot be shown by the
      compositor until it is explicitly mapped again. The layer_surface
      returns to the state it had right after layer_shell.get_layer_surface.
      The client can re-map the surface by performing a commit without any
      buffer attached, waiting for a configure event and handling it as usual.
    </description>

    <request name="set_size">
      <description summary="sets the size of the surface">
        Sets the size of the surface in surface-local coordinates. The
        compositor will display the surface centered with respect to its
        anchors.

        If you pass 0 for either value, the compositor will assign it and
        inform you of the assignment in the configure event. You must set your
        anchor to opposite edges in the dimensions you omit; not doing so is a
        protocol error. Both values are 0 by default.

        Size is double-buffered, see wl_surface.commit.
      </description>
      <arg name="width" type="uint"/>
      <arg name="height" type="uint"/>
    </request>

    <request name="set_anchor">
      <description summary="configures the anchor point of the surface">
        Requests that the compositor anchor the surface to the specified edges
        and corners. If two orthogonal edges are specified (e.g. 'top' and
        'left'), then the anchor point will be the intersection of the edges
        (e.g. the top left corner of the output); otherwise the anchor point
        will be centered on that edge, or in the center if no edge is
        specified.

        Anchor is double-buffered, see wl_surface.commit.
      </description>
      <arg name="anchor" type="uint" enum="anchor"/>
    </request>

    <request name="set_exclusive_zone">
      <description summary="configures the exclusive geometry of this surface">
        Requests that the compositor avoids occluding an area with other
        surfaces. The compositor's use of this information is
        implementation-dependent - do not assume that this region will not
        actually be occluded.

        A positive value is only meaningful if the surface is anchored to one
        edge or an edge and both perpendicular edges. If the surface is not
        anchored, anchored to only two perpendicular edges (a corner), anchored
        to only two parallel edges or anchored to all four edges, a positive
        value will be treated the same as zero.

        A positive zone is the distance from the edge in surface-local
        coordinates to consider exclusive.

        Surfaces that do not wish to have an exclusive zone may set this value
        to zero. (This is the default.)

        For example, a panel might set its exclusive zone to 10 to request that
        other surfaces do not get placed within 10 pixels of the panel's edge.

        A negative value requests that the surface be placed within so many
        pixels of the edge that it is anchored to. For example, setting an
        exclusive zone of -10 on a surface anchored to the bottom edge would
        request that the surface be placed such that the bottom 10 pixels of
        the surface is over the edge of the very bottom of the screen.

        An exclusive zone should not be larger than the width (or height, for
        top/bottom anchors) of the surface itself.

        The exclusive zone is double-buffered, see wl_surface.commit.
      </description>
      <arg name="zone" type="int"/>
    </request>

    <request name="set_margin">
      <description summary="sets a margin from the anchor point of the surface">
        Requests that the surface be placed some distance away from the anchor
        point on the output, in surface-local coordinates. Setting this value
        for edges you are not anchored to has no effect.

        The exclusive zone includes the margin.

        Margin is double-buffered, see wl_surface.commit.
      </description>
      <arg name="top" type="int"/>
      <arg name="right" type="int"/>
      <arg name="bottom" type="int"/>
      <arg name="left" type="int"/>
    </request>

    <request name="set_keyboard_interactivity">
      <description summary="requests keyboard events">
        Set to 1 to request that the seat send keyboard events to this layer
        surface. For layers below the shell surface layer, the seat will use
        normal focus semantics. For layers above the shell surface layers, the
        seat will always give this layer keyboard focus whenever the layer has
        any surfaces mapped.

        Layer surfaces receive pointer, touch, and tablet events normally. If
        you do not want to receive them, set the input region on your surface
        to an empty region.

        Events is double-buffered, see wl_surface.commit.
      </description>
      <arg name="keyboard_interactivity" type="uint" enum="keyboard_interactivity"/>
    </request>

    <request name="get_popup">
      <description summary="assign this layer_surface as an xdg_popup parent">
        This assigns an xdg_popup's parent to this layer_surface.  This popup
        should have been created via xdg_surface::get_popup with the parent set
        to NULL, or get_popup_xdg_surface, as appropriate.

        This request must be used in response to some sort of user action like a
        button press, key press, or touch down event. The serial number of the
        event should be passed as 'serial'.

        The parent of a pulldown menu is the top-level layer_surface. Subsequent
        children can be nested arbitrarily deeply.

        This request creates a grab, and must be used in conjunction with the
        grav ing protocol.

        This request must be destroyed before the layer_surface is destroyed.
      </description>
      <arg name="popup" type="object" interface="xdg_popup"/>
    </request>

    <request name="ack_configure">
      <description summary="ack a configure event">
        When a configure event is received, if a client commits the
        surface in response to the configure event, then the client
        must make an ack_configure request sometime before the commit
        request, passing along the serial of the configure event.

        For instance, the compositor might use this information during display
        configuration to change its coordinate space for set_size requests only if
        they were made before the client acknowledged the new display configuration.

        If the client receives multiple configure events before it can respond
        to one, it only has to ack the last configure event. (Because acking a
        configure event indicates that the client has applied all prior configure
        events as well.)

        A client is not required to commit immediately after acknowledging
        a configure event - it may even ack_configure several times before its
        next surface commit.

        A client may send multiple ack_configure requests before committing, but
        only the last request sent before a commit indicates which configure
        event the client really is responding to.
      </description>
      <arg name="serial" type="uint" summary="the serial from the configure event"/>
    </request>

    <request name="destroy" type="destructor">
      <description summary="destroy the layer_surface">
        This request destroys the layer surface.
      </description>
    </request>

    <event name="configure">
      <description summary="suggest a surface change">
        The configure event asks the client to resize its surface or to
        change its state. The configured state should not be applied
        immediately. See ack_configure for details.

        The width and height arguments specify the size of the window
        geometry in surface-local coordinates.

        The size is a hint, in the sense that the client is free to
        ignore it if it doesn't resize, pick a smaller size (to
        satisfy aspect ratio or resize in steps of NxM pixels). If the
        client picks a smaller size and is anchored to two opposite
        anchors (e.g. 'top' and 'bottom'), the surface will be
        centered on this axis.

        If the width or height arguments are zero, it means the client
        should decide its own window dimension.
      </description>
      <arg name="serial" type="uint"/>
      <arg name="width" type="uint"/>
      <arg name="height" type="uint"/>
    </event>

    <event name="closed">
      <description summary="surface should be closed">
        The closed event is sent by the compositor when the surface is no
        longer displayed. For instance, this may be sent when a stroke is
        dismissed, or a panel is turned off.

        If the surface has been destroyed, the closed event is unnecessary and
        is not sent. The closed event is sent before the destroy notification.

        This is a destructor, once received this object cannot be used further.
      </description>
    </event>

    <enum name="keyboard_interactivity">
      <description summary="types of keyboard interaction possible for layer shell surfaces">
        Types of keyboard interaction possible for layer shell surfaces. The
        rationale for this is twofold: (1) some applications are not interested
        in keyboard events and not allowing them to be focused can improve the
        desktop experience; (2) some applications will want to take exclusive
        keyboard focus.
      </description>
      <entry name="none" value="0">
        <description summary="no keyboard focus is possible">
          This value indicates that this surface is not interested in keyboard
          events and the compositor should never assign it the keyboard focus.

          This is the default value, set for newly created layer shell surfaces.

          This is useful for e.g. desktop wallpaper or other decorative surfaces
          that the user is not expected to interact with using the keyboard.
        </description>
      </entry>
      <entry name="exclusive" value="1">
        <description summary="request exclusive keyboard focus">
          Request exclusive keyboard focus if this surface is above the shell surface layer.

          For Normal layer surfaces, this gives up the exclusive keyboard focus request.
          For surfaces in the Top layer, this allows them to receive keyboard input.
          For surfaces in the Overlay layer, this requests that they receive exclusive
          keyboard input.

          Using this option can make a layer surface behave like a popup, but layer surfaces
          are not constrained by the size of a parent surface.

          Typically, the compositor will ignore this request if the layer surface's layer
          is not above the normal shell surface layer.

          For this type of keyboard interactivity, the focus follows the pointer when
          there are no layer surfaces with exclusive keyboard interactivity set.
        </description>
      </entry>
      <entry name="on_demand" value="2" since="4">
        <description summary="request regular keyboard focus semantics">
          This requests the compositor to allow this surface to be focused and
          unfocused by the user in an implementation-defined manner. Typically,
          the user can request focus using the keyboard tab navigation, or by
          clicking on the layer surface.

          This allows a layer surface to work more like a normal window. The focus
          may change as the user moves the pointer or navigates with the keyboard.

          This is the recommended option for layer surfaces that need keyboard
          input, as it integrates well with traditional desktop workflows.

          The compositor is free to decide how to indicate focus for this surface.
        </description>
      </entry>
    </enum>

    <enum name="anchor" bitfield="true">
      <entry name="top" value="1"/>
      <entry name="bottom" value="2"/>
      <entry name="left" value="4"/>
      <entry name="right" value="8"/>
    </enum>

    <enum name="error">
      <entry name="invalid_surface_state" value="0" summary="provided surface state is invalid"/>
      <entry name="invalid_size" value="1" summary="size is invalid"/>
      <entry name="invalid_anchor" value="2" summary="anchor bitfield is invalid"/>
      <entry name="invalid_keyboard_interactivity" value="3" summary="keyboard interactivity is invalid"/>
    </enum>
  </interface>
</protocol>
